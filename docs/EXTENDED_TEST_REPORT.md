# Расширенное тестирование backend Syt — отчёт

## 1. Recurring Engine — граничные случаи

### 1.1 DAILY + endDate
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| endDate = сегодня (UTC) | Задача создаётся в день endDate | Создаётся 1 задача | Нет |
| endDate = вчера | Задача НЕ создаётся | 0 задач (правило исключено из выборки findMany: `endDate >= startOfToday`) | Нет |

**Логика:** В `findMany` фильтр `OR: [{ endDate: null }, { endDate: { gte: startOfToday } }]` — правила с endDate в прошлом не выбираются. Дополнительно в цикле: `if (rule.endDate && rule.endDate < startOfToday) continue`.

### 1.2 WEEKLY
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| daysOfWeek = [1] (пн), день НЕ понедельник | Задача не создаётся | 0 (день был 5 — четверг) | Нет |
| Запуск в понедельник | Создаётся ровно одна | Не проверялось в этом прогоне (не был пн) | — |

**Логика:** `getISODay(today)` (date-fns), Mon=1 .. Sun=7. Совпадение с `rule.daysOfWeek`.

### 1.3 MONTHLY
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| interval = 15, сегодня 15-е | Задача создаётся | Не проверялось (сегодня было 27-е) | — |
| interval = 15, сегодня не 15-е | Задача не создаётся | 0 | Нет |
| Месяц с < 31 дня (напр. 31 число) | — | В коде: `dayOfMonth === rule.interval`. При interval=31 в феврале совпадения не будет, задача не создаётся | Логика корректна; при необходимости можно документировать «31-е = последний день месяца» |

### 1.4 CUSTOM
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| interval = 2, task.createdAt = 1 марта → задачи 1,3,5,7… | Создаются в дни 0,2,4,6… от старта | Логика: `daysSince % interval === 0` | Не прогонялось с фиксированной датой (нужна подстановка createdAt в БД) |

---

## 2. Дубликаты и race-condition

### 2.1 Параллельные вызовы POST /recurring/generate-today
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Два параллельных запроса | Одна задача на правило за день | *(исходно)* В тесте: 2 задачи с одинаковым title «Race task» | **Было** |
| Пять параллельных запросов (после доработки) | Все 200/201, без 500; дубликатов нет | Все 5 запросов вернули 201, body 0 или N; в БД по (recurringRuleId, generatedDate) дубликатов за день нет | **Нет** (защита через unique + P2002) |

### 2.2 DB-level уникальный индекс
| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Уникальный индекс (recurringRuleId, дата) | Есть | **Есть.** В Task добавлены `generatedDate DateTime?` и `@@unique([recurringRuleId, generatedDate])`; при P2002 создание пропускается | Нет |

---

## 3. TemplateTask удаление

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Создать задачу → RecurringRule → DELETE задачи | Либо 400, либо каскадное удаление правила | **200.** Правило и напоминания шаблона удаляются; у сгенерированных задач `recurringRuleId` обнуляется, затем правило удаляется | Нет. Поведение явное и предсказуемое |

**Логика:** В `TasksService.deleteTask`: удаляются reminders шаблона, для всех Task с `recurringRuleId = rule.id` выставляется `recurringRuleId = null`, удаляется RecurringRule, затем сама задача.

---

## 4. Reminder cloning

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| У шаблона 2 reminder (09:00 и 17:30) → generate-today | У новой задачи 2 reminder, время (ч:м) сохранено, новые id, sent=false | У новой задачи 2 напоминания на сегодня с 09:00 и 17:30; в ответе GET есть `sent: false` | Нет |

---

## 5. Timezone

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Пользователь timezone = "UTC+5", reminder 09:00 | Корректное сравнение remindAt <= now | Вся логика (generateRecurringTasksForToday, processDueReminders, даты задач) работает в **UTC** (startOfToday, remindAt в БД) | Нет. Поведение зафиксировано: **всё в UTC**. Учёт зоны пользователя (например, «09:00 по его времени») на уровне напоминаний/генерации не реализован — при необходимости делать в отдельном слое |

---

## 6. Users

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| firstName 100 символов (макс по DTO) | 201 | 201 | Нет |
| firstName 101 символ | 400 | 400 | Нет |
| Уникальность telegramId | На уровне БД | В Prisma: `telegramId BigInt @unique`; при дубликате возвращается 409 (ConflictException) | Нет |

---

## 7. Tasks

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Создать задачу с несуществующим userId | 404 или ошибка БД | **500** (Prisma P2003 FK violation) | **Есть:** лучше явно проверять существование пользователя и возвращать 404/400 |
| Удалить задачу, у которой есть reminders | Каскад или явное удаление | **200.** В deleteTask сначала удаляются reminders по taskId, затем задача | Нет |

**Рекомендация:** В `TasksService.createTask` перед созданием проверять существование пользователя и при отсутствии выбрасывать `NotFoundException`.

---

## 8. API Validation Hardening

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| Лишние поля в DTO (whitelist: true) | Отбрасываются, в ответе нет | 201, в ответе поля `hack` нет | Нет |
| Неверный тип (число вместо строки и т.п.) | 400 | 400 (напр. telegramId строка) | Нет |

---

## 9. Stress Test

| Проверка | Ожидаемый результат | Фактический результат | Уязвимость |
|----------|---------------------|------------------------|------------|
| 50 правил DAILY → generate-today | Все 50 задач созданы, без ошибок | Создано 50 задач, время ~0.96 с, ошибок нет | Нет |

---

## Итог: требуемые доработки

1. ~~**Race condition generate-today**~~ — сделано: unique (recurringRuleId, generatedDate), обработка P2002.
2. ~~**createTask с несуществующим userId**~~ — сделано: 404 при отсутствии пользователя.
3. **MONTHLY в коротких месяцах:** при необходимости явно описать в документации (или в коде), что interval=31 в феврале не даёт генерации; при требовании «последний день месяца» — отдельная логика.

Остальное по тестам ведёт себя ожидаемо и без выявленных логических уязвимостей.

---

## Повторное тестирование (после production-доработок)

- **GET /health:** HTTP 200, `{ "status": "ok", "timestamp": "<ISO>" }` — OK.
- **Параллельные POST /recurring/generate-today:** 5 запросов одновременно — все 200/201, без 500; дубликатов по (recurringRuleId, generatedDate) за день в БД нет.
- **Полный прогон:** `scripts/full-test.sh` — Health, Users (create, 409 duplicate telegramId, 400 invalid), Tasks (create, get, 404 bad userId, delete с reminders), Reminders, Recurring generate-today, Validation (extra fields), Delete task — все проверки пройдены.
